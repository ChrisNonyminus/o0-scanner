import os
import platform
import regex as re
import argparse

parser = argparse.ArgumentParser()

parser.add_argument('-i', '--directory', required=True, help = "Directory of binary files to scan in.")
parser.add_argument('-t', '--type', required=True, help = "Type of binary file to scan.\n\tSupported files: \"n64-ido\" (N64 roms built with IDO), \"watcom-le\" (DOS 32 bit executables built with Watcom), \"win32-msvc\" (win32 PEs built with MSVC6), \"gba\" (self explanatory).")
args = parser.parse_args()

# print(args.directory)
# print(args.type)

files = []

idoDoubleJrToNopRegex = b'[\s\S][\s\S][\s\S]\x08\x00\x00\x00\x00[\s\S][\s\S][\s\S]\x08\x00\x00\x00\x00'
watcomStackEpilogRegex = b'\x5F\x5E\x5A\x59\x5B\x5D\xC3'
msvcStackEpilogPrologRegex = b'\x55\x89\x8b\xec[^\xc3\xc2]*\x5d[\xc3\xc2]'
agbccPotentialO0PrologRegex = b'\x80\xb5\x6f\x46'

results = []

for file in os.listdir(args.directory):
    file = args.directory + "/" + file
    if args.type == "n64-ido":
        if file.upper().endswith(".N64") or file.upper().endswith(".NDD"):
            data = open(file, 'rb').read()
            m = re.findall(idoDoubleJrToNopRegex, data, overlapped=False)
            if m:
                print(f'"{file}" had {len(m)} hits when searching for double instances of jr instructions followed by nops.\n')
                results.append(f'"{file}" had {len(m)} hits when searching for double instances of jr instructions followed by nops.\n')
    if args.type == "gba":
        if file.upper().endswith(".GBA"):
            data = open(file, 'rb').read()
            m = re.findall(agbccPotentialO0PrologRegex, data, overlapped=False )
            if m:
                print(f'"{file}" had {len(m)} hits when searching for what seems like a prolog often generated by agbcc o0.\n')
                results.append(f'"{file}" had {len(m)} hits when searching for what seems like a prolog often generated by agbcc o0.\n')
    if args.type in ["watcom-le"]:
        if file.upper().endswith(".EXE"):
            data = open(file, 'rb').read()
            m = re.findall(watcomStackEpilogRegex, data, overlapped=True )
            if m:
                print(f'"{file}" had {len(m)} hits when searching for "chunky" stack popping epilogs.\n')
                results.append(f'"{file}" had {len(m)} hits when searching for "chunky" stack popping epilogs.\n')
    if args.type in ["win32-msvc"]:
        if file.upper().endswith(".EXE"):
            data = open(file, 'rb').read()
            m = re.findall(msvcStackEpilogPrologRegex, data, overlapped=True )
            if m:
                print(f'"{file}" had {len(m)} hits when searching for excessive use of the stack.\n')
                results.append(f'"{file}" had {len(m)} hits when searching for excessive use of the stack.\n')

def sortfunc(e):
    m = re.match(r'.*had (.*) hits.*', e)
    if m:
        return int(m.groups()[0])
    return 0

results.sort(key=sortfunc)

resultfile = open("./results.txt", 'w')
for result in results:
    resultfile.write(result)
